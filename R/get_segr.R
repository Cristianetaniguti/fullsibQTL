#######################################################################
#                                                                     #
# Package: fullsibQTL                                                 #
#                                                                     #
# File: get_segr.R                                                    #
#                                                                     # 
# Contains: get_segr                                                  #
#                                                                     #
#                                                                     #
# An adaption by Rodrigo Gazaffi, for the print.sequence function     #
# present in onemap package                                           #
# Updated by Rodrigo Amadeu                                           #
#                                                                     #
# copyright (c) 2011, Rodrigo Gazaffi                                 #
#                                                                     #
# First version: 09/30/2011 (american date format)                    #
# Last  version: 08/23/2017 (american date format)                    #
# License: GNU General Public License version 2 (June, 1991) or later #
#                                                                     #
#######################################################################

#######################################################################
#                                                                     #
# Function:   get_segr.R                                              #
#                                                                     # 
# Receives the object of class fullsib_char with QTL information and  #
# returns the QTL segregation                                         #
#                                                                     #
#######################################################################


## -------------------------
## get_segr function

#' Indicates the segregation of mapped QTL
#' 
#' Indicates the QTL segregation for the result generated by both
#' \code{im_char} and \code{cim_char}.
#' 
#' QTL mapping procedure considered here, supposes that QTL can have differents
#' segregation patterns on the progeny. In a diploid species, one can find QTL
#' showing 1:1:1:1, 1:2:1, 3:1 and 1:1 fashion. This segregations are function
#' of the number and the magnitude of significative effects.
#' 
#' To identify the segregation, a two step procedure is done. First, we test if
#' additive effects in both parents and dominance are signficative
#' (\eqn{H_{01}}, \eqn{H_{02}} and \eqn{H_{03}}), and we infer if they are
#' significative based on probs1). If more than one QTL if significative we
#' need to test if they are similar in magnitude (not considering the signal).
#' Probs2 is used to define if \eqn{H_{04}}, \eqn{H_{05}} and \eqn{H_{06}}, are
#' significative. With the interpretation of this hypothesis the segregation is
#' inferred. The details about these tests are can be found in Gazaffi et al.
#' (2014). For the situations which some genetic effects are not estimable, the
#' explanation of segregation is present in \code{fullsibQTL} Vignette.
#' 
#' @param fschar An object from class \emph{fullsib_char}.
#' @param probs1 probability used to identify significative effects on
#' hypothesis \eqn{H_{01}}, \eqn{H_{02}} and \eqn{H_{03}}. See details.
#' @param probs2 probability used to identify significative hypothesis for
#' \eqn{H_{04}}, \eqn{H_{05}} and \eqn{H_{06}}. See details.
#' 
#' @return This function returns text output indicating the QTL segregation
#' 
#' @author Rodrigo Gazaffi \email{rgazaffi@@gmail.com}
#' @seealso 
#' \code{\link[fullsibQTL]{im_char}}
#' \code{\link[fullsibQTL]{cim_char}}
#' \code{\link[fullsibQTL]{draw_phase}}
#' 
#' @references Gazaffi, R.; Margarido, G. R.; Pastina, M. M.; Mollinari, M.;
#' Garcia, A. A. F. (2014) A model for Quantitative Trait Loci Mapping, Linkage
#' Phase, and Segregation Pattern Estimation for a Full-Sib Progeny. \emph{Tree
#' Genetics & Genomes} 10(4): 791-801
#' 
#' @keywords utilities
#' @examples
#'   data( "example_QTLfullsib" )
#' 
#'   fullsib <- create_fullsib( example_QTLfullsib,
#'                              list( LG1_final, LG2_final, LG3_final, LG4_final ),
#'                              step = 0, map.function = "kosambi", condIndex = 3.5 )
#' 
#' 
#'   ###############################################
#'   ## cofactor selection using BIC (n.ind = 300)
#'   cofs.fs <- cof_selection( fullsib, pheno.col = 1, k = log( 300 ),
#'                             selection = 1 ) 
#' 
#'   \dontrun{
#'   cim1 <- cim_scan( cofs.fs, pheno.col = 1, ws = 22, LOD = TRUE, icim = FALSE )
#'   summary( cim1 )
#'   plot( cim1 )
#'   }
#' 
#'   qtl.lg3 <- cim_char( cofs.fs, pheno.col = 1, ws = 22, lg = 3, pos = "M38" )
#'   get_segr( qtl.lg3 )
#' 
#'   qtl.lg4 <- cim_char( cofs.fs, pheno.col = 1, ws = 22, lg = 4, pos = "M52" )
#'   get_segr( qtl.lg4 )
#' 
#' @importFrom stats qchisq 
#' @export
get_segr <- function( fschar, probs1 = .05, probs2 = .05 ){

  if (!any(class(fschar) == "fullsib_char"))
    stop(sQuote(deparse(substitute(fschar))),
         " is not an object of class 'fullsib_char'")

  if((probs1 < 0 ) || (probs1 > 1))
    stop("probs1 argument should be a probability between 0 and 1")
  
  if((probs2 < 0 ) || (probs2 > 1))
    stop("probs2 argument should be a probability between 0 and 1")
  
  ##iddentify performed tests
  used.model <- fschar["model",]
  
  ##step1 in lod
  step1 <- fschar[c("LOD_H1", "LOD_H2", "LOD_H3"),]
  ##threshold probs1 em thr.lod
  thr.lod <- qchisq(probs1, 1, lower.tail=FALSE)/4.61
  
  ##step2 in pvalue
  step2 <- fschar[c("H4_pvalue", "H5_pvalue", "H6_pvalue"),]

  #######################################################
  ## model used when three genetics effects are estimable
  #######################################################

  if(used.model == 0){
    signif.lod <- step1 > thr.lod

    if (sum(signif.lod) == 0) # no signif ef.
      return(cat("No QTL is considered with probs1 = ", probs1, "\n"))
    
    x<-function(){cat("QTL segregation is 1:1");return(invisible("1:1"))}
    
    if (sum(signif.lod) == 1){ # only one signif ef.
      cat("QTL segregation is 1:1")
      return("1:1")
    }
    if (sum(signif.lod) == 2){ # two signf ef.
      signif.lod <- paste(which(signif.lod),collapse=":")
      switch(EXPR = signif.lod,
             '1:2' = {
               if(step2[1] < probs2){
                 cat("QTL segregation is 1:1:1:1\n")
                 return(invisible("1:1:1:1"))
               }else{
                 cat("QTL segregation is 1:2:1\n")
                 return(invisible("1:2:1"))
               }
             },
             '1:3' = {
               if(step2[2] < probs2){
                 cat("QTL segregation is 1:1:1:1\n")
                 return(invisible("1:1:1:1"))
               }
               else{
                 cat("QTL segregation is 1:2:1\n")
                 return(invisible("1:2:1"))
               }
             },
             '2:3' = {
               if(step2[3] < probs2){
                 cat("QTL segregation is 1:1:1:1\n")
                 return(invisible("1:1:1:1"))
               }
               else{
                 cat("QTL segregation is 1:2:1\n")
                 return(invisible("1:2:1"))
               }
               
             })#end-switch
    }

    if (sum(signif.lod) == 3){ # three signf ef.
      signif.pvalue <- as.character(sum(step2 > probs2))
      switch(EXPR = signif.pvalue,
             '3' = {cat("QTL segregation is 3:1\n");return(invisible("3:1"))},
             '1' = {cat("QTL segregation is 1:2:1\n");return(invisible("1:2:1"))},
             {cat("QTL segregation is 1:1:1:1\n");return(invisible("1:1:1:1"))})
    }
  } #end - used.model==0

  #######################################################
  ## model used when just one additive effect is estimable
  #######################################################
  
  if(used.model == 1){ ## just ap is estimable
    if(step1[1] > thr.lod){
        cat("QTL segregation is 1:1\n")
        return(invisible("1:1"))
    }else
      return(cat("No QTL is considered with probs1 = ", probs1, "\n"))
  }

  if(used.model == 2){ ## just aq is estimable
    if(step1[2] > thr.lod){
      cat("QTL segregation is 1:1\n")
      return(invisible("1:1"))
    }else
      return(cat("No QTL is considered with probs1 = ", probs1, "\n"))
  }
  
  #######################################################
  ## model used when "two" additive effect is estimable
  #######################################################

  if((used.model == 3) || (used.model == 4)){ ##1 and (4 or 5)
    signif.lod <- step1[1:2] > thr.lod
    if(sum(signif.lod, na.rm=T) == 0) return(cat("No QTL is considered with probs1 =", probs1, "\n"))
    if(sum(signif.lod, na.rm=T) == 1){
      if(signif.lod[1] == TRUE){
        cat("QTL segregation is 1:1\n")
        return(invisible("1:1"))
      }
      if(signif.lod[2] == TRUE){
        cat("QTL segregation is 1:2:1\n")
        return(invisible("1:2:1"))
      }
    }
    if(sum(signif.lod, na.rm=T) == 2){
      if(step2[1] < probs2){
        cat("QTL segregation is 1:2:1\n")
        return(invisible("1:2:1"))
      }else{
        cat("QTL segregation is 3:1\n")
        return(invisible("3:1"))
      }
    }
  }

    if((used.model == 5) || (used.model == 6)){ ## (6 or 7) and 2
    signif.lod <- step1[1:2] > thr.lod
    if(sum(signif.lod, na.rm=T) == 0) return(cat("No QTL is considered with probs1 =", probs1, "\n"))
    if(sum(signif.lod, na.rm=T) == 1){
      if(signif.lod[1] == TRUE){
        cat("QTL segregation is 1:2:1\n")
        return(invisible("1:2:1"))
      }
      if(signif.lod[2] == TRUE){
        cat("QTL segregation is 1:1\n")
        return(invisible("1:1"))
      }
    }
    if(sum(signif.lod, na.rm=T) == 2){
      if(step2[1] < probs2){
        cat("QTL segregation is 1:2:1\n")
        return(invisible("1:2:1"))
      }else{
        cat("QTL segregation is 3:1\n")
        return(invisible("3:1"))
      }
    }
  }
  
  if((used.model == 7) || (used.model == 8)){ ##(8 or 9)  and 3
    signif.lod <- step1[c(1,3)] > thr.lod
    if(sum(signif.lod, na.rm=T) == 0) return(cat("No QTL is considered with probs1 =", probs1, "\n"))
    if(sum(signif.lod, na.rm=T) == 1){
      if(signif.lod[1] == TRUE){
        cat("QTL segregation is 1:2:1\n")
        return(invisible("1:2:1"))
      }
      if(signif.lod[2] == TRUE){
        cat("QTL segregation is 1:1\n")
        return(invisible("1:1"))
      }
    }
    if(sum(signif.lod, na.rm=T) == 2){
      if(step2[2] < probs2){
        cat("QTL segregation is 1:2:1\n")
        return(invisible("1:2:1"))
      }else{
        cat("QTL segregation is 3:1\n")
        return(invisible("3:1"))
      }
    }              
  }
  
  #######################################################
  ## model used when LG have mkr with 3:1 fashion in coupling
  #######################################################

  if(used.model > 8) {
    if(step1[1] > thr.lod){
      cat("QTL segregation is 3:1\n")
      return(invisible("3:1"))
    }else
      return(cat("No QTL is considered with probs1 =", probs1, "\n"))
  }
  
}

